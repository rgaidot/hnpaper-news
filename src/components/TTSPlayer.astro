---
interface Props {
  title: string;
  readingTime?: number;
}

const { title, readingTime } = Astro.props;
---

<div class="tts-player-container flex items-center justify-center space-x-2 mt-4" data-title={title}>
  <button class="play-pause-tts p-2 rounded-full bg-stone-200 hover:bg-stone-300 text-stone-800 transition-colors duration-200">
    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
      <path stroke-linecap="round" stroke-linejoin="round" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z" />
      <path stroke-linecap="round" stroke-linejoin="round" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
    </svg>
  </button>
  <button class="stop-tts p-2 rounded-full bg-stone-200 hover:bg-stone-300 text-stone-800 transition-colors duration-200 hidden">
    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
      <path stroke-linecap="round" stroke-linejoin="round" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0zM9 10a1 1 0 011-1h4a1 1 0 011 1v4a1 1 0 01-1 1h-4a1 1 0 01-1-1v-4z" />
    </svg>
  </button>
  <select class="tts-speed p-2 rounded bg-stone-200 hover:bg-stone-300 text-stone-800 transition-colors duration-200 border-none text-sm cursor-pointer outline-none font-medium" aria-label="Vitesse de lecture">
    <option value="0.75">0.75x</option>
    <option value="1" selected>1x</option>
    <option value="1.25">1.25x</option>
    <option value="1.5">1.5x</option>
    <option value="2">2x</option>
    <option value="2.5">2.5x</option>
    <option value="3">3x</option>
    <option value="3.5">3.5x</option>
    <option value="4">4x</option>
    <option value="4.5">4.5x</option>
  </select>
  {readingTime && (
    <span class="tts-reading-time text-xs font-sans font-bold uppercase tracking-widest text-stone-500" data-base-time={readingTime}>{readingTime} min</span>
  )}
  <span class="tts-status text-sm text-stone-600 italic">Prêt à lire</span>
</div>

<script>
  function initTTS() {
    const containers = document.querySelectorAll('.tts-player-container');
    if (containers.length === 0) return;
    
    const articleContent = document.querySelector('.prose');
    let contentText = "";
    let wordMap: { start: number, end: number, element: HTMLElement }[] = [];

    const prepareText = () => {
      if (!articleContent) return;

      const ignorePatterns = [
          /^\s*Discussion HN\s*:/i,
          /^\s*Article source\s*:/i
      ];
      const candidates = articleContent.querySelectorAll('li, p');
      candidates.forEach(el => {
          if (ignorePatterns.some(p => p.test(el.textContent || ''))) {
              el.classList.add('tts-ignore');
          }
      });

      if (articleContent.querySelector('.tts-word')) {
        rebuildMap();
        return;
      }

      const walker = document.createTreeWalker(articleContent, NodeFilter.SHOW_TEXT, {
        acceptNode: (node) => {
            if (node.parentElement && node.parentElement.closest('.tts-ignore')) {
                return NodeFilter.FILTER_REJECT;
            }
            return NodeFilter.FILTER_ACCEPT;
        }
      });
      const nodesToReplace: Text[] = [];
      while(walker.nextNode()) {
        nodesToReplace.push(walker.currentNode as Text);
      }

      nodesToReplace.forEach(node => {
        const text = node.textContent || "";
        if (!text.trim()) return; 

        const fragment = document.createDocumentFragment();
        const parts = text.split(/(\s+)/);
        
        parts.forEach(part => {
          if (!part) return;
          if (part.match(/\s+/)) {
            fragment.appendChild(document.createTextNode(part));
          } else {
            const span = document.createElement('span');
            span.textContent = part;
            span.className = 'tts-word';
            fragment.appendChild(span);
          }
        });
        
        node.parentNode?.replaceChild(fragment, node);
      });
      
      rebuildMap();
    };

    const rebuildMap = () => {
      if (!articleContent) return;
      wordMap = [];
      contentText = "";
      
      const spans = articleContent.querySelectorAll('.tts-word');
      spans.forEach(span => {
        if (span.closest('.tts-ignore')) return;

        const word = span.textContent || "";
        wordMap.push({
          start: contentText.length,
          end: contentText.length + word.length,
          element: span as HTMLElement
        });
        contentText += word + " ";
      });
    };

    prepareText();

    let playAtGlobal: ((index: number) => void) | null = null;
    let titleTextLen = 0;

    containers.forEach(container => {
      const playPauseButton = container.querySelector('.play-pause-tts') as HTMLButtonElement;
      const stopButton = container.querySelector('.stop-tts') as HTMLButtonElement;
      const ttsStatus = container.querySelector('.tts-status') as HTMLElement;
      const speedSelect = container.querySelector('.tts-speed') as HTMLSelectElement;
      const readingTimeSpan = container.querySelector('.tts-reading-time') as HTMLElement;
      
      if (!playPauseButton || !stopButton || !ttsStatus || !speedSelect) return;

      const articleTitle = container.getAttribute('data-title') || '';
      const titleText = articleTitle + ". ";
      
      if (container.hasAttribute('data-tts-initialized')) {
          const storedPlayAt = (container as any)._playAt;
          if (storedPlayAt && !playAtGlobal) {
              playAtGlobal = storedPlayAt;
              titleTextLen = titleText.length;
          }
          return;
      }
      container.setAttribute('data-tts-initialized', 'true');

      let utterance: SpeechSynthesisUtterance | null = null;
      let currentState: 'stopped' | 'playing' | 'paused' = 'stopped';
      let currentCharIndex = 0;
      let fullText = "";
      let sentences: { text: string, start: number }[] = [];
      let currentSentenceIndex = 0;

      const updateUI = (state: 'playing' | 'paused' | 'stopped' | 'error') => {
        currentState = state === 'error' ? 'stopped' : state;
        
        window.dispatchEvent(new CustomEvent('tts-state-change', { 
            detail: { state: currentState } 
        }));

        if (state === 'playing') {
          playPauseButton.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
              <path stroke-linecap="round" stroke-linejoin="round" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>
          `;
          stopButton.classList.remove('hidden');
          ttsStatus.textContent = "Lecture en cours...";
        } else if (state === 'paused') {
          playPauseButton.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
              <path stroke-linecap="round" stroke-linejoin="round" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z" />
              <path stroke-linecap="round" stroke-linejoin="round" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>
          `;
          stopButton.classList.remove('hidden');
          ttsStatus.textContent = "En pause";
        } else if (state === 'error') {
          playPauseButton.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
              <path stroke-linecap="round" stroke-linejoin="round" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
            </svg>
          `;
          stopButton.classList.add('hidden');
          ttsStatus.textContent = "Erreur: désactivez Metamask";
        } else {
          playPauseButton.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
              <path stroke-linecap="round" stroke-linejoin="round" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z" />
              <path stroke-linecap="round" stroke-linejoin="round" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>
          `;
          stopButton.classList.add('hidden');
          ttsStatus.textContent = "Prêt à lire";
        }
      };

      const clearHighlight = () => {
         const currentActive = articleContent?.querySelector('.tts-active');
         if (currentActive) currentActive.classList.remove('tts-active');
      };

      const speak = (textToSpeak: string, offset: number = 0) => {
        if (!window.speechSynthesis) {
          updateUI('error');
          return;
        }

        try {
          window.speechSynthesis.cancel();
        } catch (e) {
        }

        utterance = new SpeechSynthesisUtterance(textToSpeak);
        utterance.lang = 'fr-FR';
        utterance.rate = parseFloat(speedSelect.value) || 1;
        utterance.pitch = 1.0;
        utterance.volume = 1.0;
        
        const voices = window.speechSynthesis.getVoices();
        const frVoice = voices.find(v => v.lang.startsWith('fr'));
        if (frVoice) utterance.voice = frVoice;

        utterance.onstart = () => {
          if (currentState === 'playing') {
          }
        };
        
        utterance.onend = () => {
          if (currentState === 'paused' || currentState === 'stopped') {
            return;
          }
          currentSentenceIndex++;
          if (currentSentenceIndex < sentences.length) {
              const s = sentences[currentSentenceIndex];
              speak(s.text, s.start);
          } else {
              clearHighlight();
              currentCharIndex = 0;
              updateUI('stopped');
          }
        };
        
        utterance.onerror = (event) => {
          if (currentState === 'paused' || currentState === 'stopped') {
            return;
          }
          
          console.error('Speech error:', event.error);
          
          if (event.error !== 'interrupted') {
            clearHighlight();
            if (event.error === 'not-allowed' || event.error === 'synthesis-unavailable') {
              updateUI('error');
            } else {
              updateUI('stopped');
            }
          }
        };

        utterance.onboundary = (event) => {
            if (event.name === 'word') {
                const charIndex = event.charIndex + offset;
                currentCharIndex = charIndex;
                
                if (charIndex < titleText.length) {
                    clearHighlight();
                    return;
                }
                
                const relativeIndex = charIndex - titleText.length;
                const match = wordMap.find(w => relativeIndex >= w.start - 1 && relativeIndex < w.end);
                
                if (match) {
                    clearHighlight();
                    match.element.classList.add('tts-active');
                    match.element.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            }
        };

        try {
          window.speechSynthesis.speak(utterance);
        } catch (e) {
          console.error('Error starting speech:', e);
          updateUI('error');
        }
      };

      const prepareSentences = () => {
        if (!contentText) {
          prepareText();
        }
        
        let bodyText = "";
        if (articleContent) {
          bodyText = contentText || (articleContent as HTMLElement).innerText;
        }

        fullText = titleText + bodyText;
        if (fullText.trim().length <= titleText.length) {
           console.warn("No text content found to speak.");
           sentences = [];
           return;
        }
        
        let segments: string[] = [];
        if (typeof Intl !== 'undefined' && 'Segmenter' in Intl) {
            const segmenter = new Intl.Segmenter('fr', { granularity: 'sentence' });
            segments = Array.from(segmenter.segment(fullText)).map(s => s.segment);
        } else {
            segments = fullText.match(/[\s\S]*?[.!?]+(?:\s+|$)|[\s\S]+$/g) || [fullText];
        }
        
        let cursor = 0;
        sentences = segments.map(t => {
            const entry = { text: t, start: cursor };
            cursor += t.length;
            return entry;
        });
      };

      const playAt = (index: number) => {
         if (!window.speechSynthesis) return;
         
         if (sentences.length === 0) {
             prepareSentences();
         }
         
         const sIdx = sentences.findIndex(s => index >= s.start && index < s.start + s.text.length);
         if (sIdx === -1) return;
         
         currentSentenceIndex = sIdx;
         currentCharIndex = index;
         
         updateUI('playing');
         
         const s = sentences[currentSentenceIndex];
         const localOffset = Math.max(0, currentCharIndex - s.start);
         const remainingText = s.text.substring(localOffset);
         
         speak(remainingText, currentCharIndex);
      };

      const playFromElement = (targetEl: HTMLElement) => {
          if (!targetEl) return;
          const match = wordMap.find(w => targetEl.contains(w.element) || w.element === targetEl);
          if (match) {
              playAt(titleTextLen + match.start);
          } else {
          }
      };

      const togglePlay = () => {
          playPauseButton.click();
      };

      (container as any)._playAt = playAt;
      (container as any)._playFromElement = playFromElement;
      (container as any)._togglePlay = togglePlay;

      if (!playAtGlobal) {
          playAtGlobal = playAt;
          titleTextLen = titleText.length;
      }

      speedSelect.addEventListener('change', () => {
        const newRate = parseFloat(speedSelect.value) || 1;
        
        if (readingTimeSpan && readingTimeSpan.dataset.baseTime) {
          const baseTime = parseFloat(readingTimeSpan.dataset.baseTime);
          const newTime = Math.ceil(baseTime / newRate);
          readingTimeSpan.textContent = `${newTime} min`;
        }

        if (currentState === 'playing') {
          window.speechSynthesis.cancel();
          
          if (currentSentenceIndex < 0 || currentSentenceIndex >= sentences.length) {
             currentSentenceIndex = 0;
          }

          let s = sentences[currentSentenceIndex];
          
          if (currentCharIndex < s.start || currentCharIndex >= s.start + s.text.length) {
             currentCharIndex = s.start;
          }

          const localOffset = Math.max(0, currentCharIndex - s.start);
          const remainingText = s.text.substring(localOffset);
          
          if (remainingText.trim()) {
            speak(remainingText, currentCharIndex);
          } else {
            currentSentenceIndex++;
            if (currentSentenceIndex < sentences.length) {
                s = sentences[currentSentenceIndex];
                currentCharIndex = s.start;
                speak(s.text, s.start);
            } else {
                clearHighlight();
                currentCharIndex = 0;
                currentSentenceIndex = 0;
                updateUI('stopped');
            }
          }
        }
      });

      playPauseButton.addEventListener('click', () => {
        if (!window.speechSynthesis) {
          updateUI('error');
          return;
        }

        if (currentState === 'paused') {
          updateUI('playing');

          if (currentSentenceIndex < 0 || currentSentenceIndex >= sentences.length) {
             currentSentenceIndex = 0;
          }

          let s = sentences[currentSentenceIndex];
          
          if (currentCharIndex < s.start || currentCharIndex >= s.start + s.text.length) {
             currentCharIndex = s.start;
          }

          const localOffset = Math.max(0, currentCharIndex - s.start);
          const remainingText = s.text.substring(localOffset);
          
          if (remainingText.trim()) {
            speak(remainingText, currentCharIndex);
          } else {
            currentSentenceIndex++;
            if (currentSentenceIndex < sentences.length) {
                s = sentences[currentSentenceIndex];
                currentCharIndex = s.start;
                speak(s.text, s.start);
            } else {
                clearHighlight();
                currentCharIndex = 0;
                currentSentenceIndex = 0;
                updateUI('stopped');
            }
          }
          return;
        }

        if (currentState === 'playing') {
          updateUI('paused');
          try {
            window.speechSynthesis.cancel();
          } catch (e) {
            console.error('Error pausing speech:', e);
          }
          return;
        }

        prepareSentences();
        
        currentCharIndex = 0;
        currentSentenceIndex = 0;
        
        if (sentences.length > 0) {
            updateUI('playing');
            speak(sentences[0].text, sentences[0].start);
        }
      });

      stopButton.addEventListener('click', () => {
        try {
          updateUI('stopped');
          window.speechSynthesis.cancel();
          clearHighlight();
          currentCharIndex = 0;
          currentSentenceIndex = 0;
        } catch (e) {
          console.error('Error stopping speech:', e);
        }
      });
    });

    if (window.speechSynthesis) {
        window.speechSynthesis.onvoiceschanged = () => {
          window.speechSynthesis.getVoices();
        };
    }

    if (articleContent) {
        const existingHandler = (articleContent as any)._ttsClickHandler;
        if (existingHandler) {
            articleContent.removeEventListener('click', existingHandler);
        }
        
        const clickHandler = (e: Event) => {
            const target = e.target as HTMLElement;
            if (!target.classList.contains('tts-word')) return;
            
            const entry = wordMap.find(w => w.element === target);
            if (entry && playAtGlobal) {
                playAtGlobal(titleTextLen + entry.start);
            }
        };
        
        articleContent.addEventListener('click', clickHandler);
        (articleContent as any)._ttsClickHandler = clickHandler;
    }
  }

  if (document.readyState !== 'loading') {
    initTTS();
  } else {
    document.addEventListener('DOMContentLoaded', initTTS);
  }
  
  document.addEventListener('astro:page-load', initTTS);

  document.addEventListener('keydown', (event) => {
    if (event.code === 'Space' && !event.repeat) {
      const firstPlayPauseButton = document.querySelector('.play-pause-tts') as HTMLButtonElement;
      if (firstPlayPauseButton) {
        event.preventDefault();
        firstPlayPauseButton.click();
      }
    }
  });
</script>
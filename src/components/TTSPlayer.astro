---
interface Props {
  title: string;
}

const { title } = Astro.props;
---

<div class="tts-player-container flex items-center justify-center space-x-2 mt-4" data-title={title}>
  <button class="play-pause-tts p-2 rounded-full bg-stone-200 hover:bg-stone-300 text-stone-800 transition-colors duration-200">
    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
      <path stroke-linecap="round" stroke-linejoin="round" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z" />
      <path stroke-linecap="round" stroke-linejoin="round" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
    </svg>
  </button>
  <button class="stop-tts p-2 rounded-full bg-stone-200 hover:bg-stone-300 text-stone-800 transition-colors duration-200 hidden">
    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
      <path stroke-linecap="round" stroke-linejoin="round" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0zM9 10a1 1 0 011-1h4a1 1 0 011 1v4a1 1 0 01-1 1h-4a1 1 0 01-1-1v-4z" />
    </svg>
  </button>
  <span class="tts-status text-sm text-stone-600 italic">Prêt à lire</span>
</div>

<script>
  function initTTS() {
    const containers = document.querySelectorAll('.tts-player-container');
    if (containers.length === 0) return;
    
    const articleContent = document.querySelector('.prose');
    let contentText = "";
    let wordMap: { start: number, end: number, element: HTMLElement }[] = [];

    const prepareText = () => {
      if (!articleContent) return;

      // Mark ignored content first
      const ignorePatterns = [
          /Discussion HN\s*:/i,
          /Article source\s*:/i
      ];
      const candidates = articleContent.querySelectorAll('li, p');
      candidates.forEach(el => {
          if (ignorePatterns.some(p => p.test(el.textContent || ''))) {
              el.classList.add('tts-ignore');
          }
      });

      if (articleContent.querySelector('.tts-word')) {
        rebuildMap();
        return;
      }

      const walker = document.createTreeWalker(articleContent, NodeFilter.SHOW_TEXT, {
        acceptNode: (node) => {
            if (node.parentElement && node.parentElement.closest('.tts-ignore')) {
                return NodeFilter.FILTER_REJECT;
            }
            return NodeFilter.FILTER_ACCEPT;
        }
      });
      const nodesToReplace: Text[] = [];
      while(walker.nextNode()) {
        nodesToReplace.push(walker.currentNode as Text);
      }

      nodesToReplace.forEach(node => {
        const text = node.textContent || "";
        if (!text.trim()) return; 

        const fragment = document.createDocumentFragment();
        const parts = text.split(/(\s+)/);
        
        parts.forEach(part => {
          if (!part) return;
          if (part.match(/\s+/)) {
            fragment.appendChild(document.createTextNode(part));
          } else {
            const span = document.createElement('span');
            span.textContent = part;
            span.className = 'tts-word';
            fragment.appendChild(span);
          }
        });
        
        node.parentNode?.replaceChild(fragment, node);
      });
      
      rebuildMap();
    };

    const rebuildMap = () => {
      if (!articleContent) return;
      wordMap = [];
      contentText = "";
      
      const spans = articleContent.querySelectorAll('.tts-word');
      spans.forEach(span => {
        // Double check if span is inside ignored element (in case it was added dynamically or missed)
        if (span.closest('.tts-ignore')) return;

        const word = span.textContent || "";
        wordMap.push({
          start: contentText.length,
          end: contentText.length + word.length,
          element: span as HTMLElement
        });
        contentText += word + " ";
      });
    };

    prepareText();

    containers.forEach(container => {
      if (container.hasAttribute('data-tts-initialized')) return;
      container.setAttribute('data-tts-initialized', 'true');

      const playPauseButton = container.querySelector('.play-pause-tts') as HTMLButtonElement;
      const stopButton = container.querySelector('.stop-tts') as HTMLButtonElement;
      const ttsStatus = container.querySelector('.tts-status') as HTMLElement;
      
      if (!playPauseButton || !stopButton || !ttsStatus) return;

      if (!window.speechSynthesis) {
        container.style.display = 'none';
        return;
      }

      const articleTitle = container.getAttribute('data-title') || '';
      const titleText = articleTitle + ". ";
      
      let utterance: SpeechSynthesisUtterance | null = null;
      let currentState: 'stopped' | 'playing' | 'paused' = 'stopped';
      let currentCharIndex = 0;
      let fullText = "";
      let isPausingManually = false;
      let sentences: { text: string, start: number }[] = [];
      let currentSentenceIndex = 0;

      const updateUI = (state: 'playing' | 'paused' | 'stopped' | 'error') => {
        currentState = state === 'error' ? 'stopped' : state;
        
        if (state === 'playing') {
          playPauseButton.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
              <path stroke-linecap="round" stroke-linejoin="round" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>
          `;
          stopButton.classList.remove('hidden');
          ttsStatus.textContent = "Lecture en cours...";
        } else if (state === 'paused') {
          playPauseButton.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
              <path stroke-linecap="round" stroke-linejoin="round" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z" />
              <path stroke-linecap="round" stroke-linejoin="round" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>
          `;
          stopButton.classList.remove('hidden');
          ttsStatus.textContent = "En pause";
        } else if (state === 'error') {
          playPauseButton.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
              <path stroke-linecap="round" stroke-linejoin="round" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
            </svg>
          `;
          stopButton.classList.add('hidden');
          ttsStatus.textContent = "Erreur: désactivez Metamask";
        } else {
          playPauseButton.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
              <path stroke-linecap="round" stroke-linejoin="round" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z" />
              <path stroke-linecap="round" stroke-linejoin="round" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>
          `;
          stopButton.classList.add('hidden');
          ttsStatus.textContent = "Prêt à lire";
        }
      };

      const clearHighlight = () => {
         const currentActive = articleContent?.querySelector('.tts-active');
         if (currentActive) currentActive.classList.remove('tts-active');
      };

      const speak = (textToSpeak: string, offset: number = 0) => {
        if (!window.speechSynthesis) {
          updateUI('error');
          return;
        }

        try {
          window.speechSynthesis.cancel();
        } catch (e) {
          // Ignore
        }

        utterance = new SpeechSynthesisUtterance(textToSpeak);
        utterance.lang = 'fr-FR';
        utterance.rate = 1;
        utterance.pitch = 1.0;
        utterance.volume = 1.0;
        
        const voices = window.speechSynthesis.getVoices();
        const frVoice = voices.find(v => v.lang.startsWith('fr'));
        if (frVoice) utterance.voice = frVoice;

        utterance.onstart = () => {
          if (!isPausingManually) {
            updateUI('playing');
          }
        };
        
        utterance.onend = () => {
          if (!isPausingManually) {
            currentSentenceIndex++;
            if (currentSentenceIndex < sentences.length) {
                const s = sentences[currentSentenceIndex];
                speak(s.text, s.start);
            } else {
                clearHighlight();
                currentCharIndex = 0;
                updateUI('stopped');
            }
          }
        };
        
        utterance.onerror = (event) => {
          // Ignorer l'erreur "interrupted" qui vient de la pause manuelle
          if (event.error === 'interrupted' && isPausingManually) {
            return;
          }
          
          console.error('Speech error:', event.error);
          
          if (!isPausingManually) {
            clearHighlight();
            
            if (event.error === 'not-allowed' || event.error === 'synthesis-unavailable') {
              updateUI('error');
            } else if (event.error !== 'interrupted') {
              updateUI('stopped');
            }
          }
        };

        utterance.onboundary = (event) => {
            if (event.name === 'word') {
                const charIndex = event.charIndex + offset;
                currentCharIndex = charIndex;
                
                if (charIndex < titleText.length) {
                    clearHighlight();
                    return;
                }
                
                const relativeIndex = charIndex - titleText.length;
                const match = wordMap.find(w => Math.abs(w.start - relativeIndex) <= 1);
                
                if (match) {
                    clearHighlight();
                    match.element.classList.add('tts-active');
                    match.element.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            }
        };

        try {
          window.speechSynthesis.speak(utterance);
        } catch (e) {
          console.error('Error starting speech:', e);
          updateUI('error');
        }
      };

      playPauseButton.addEventListener('click', () => {
        if (!window.speechSynthesis) {
          updateUI('error');
          return;
        }

        // Si en pause, reprendre
        if (currentState === 'paused') {
          let sIndex = sentences.findIndex(s => currentCharIndex >= s.start && currentCharIndex < s.start + s.text.length);
          if (sIndex === -1) sIndex = 0;

          currentSentenceIndex = sIndex;
          const s = sentences[sIndex];
          const localOffset = Math.max(0, currentCharIndex - s.start);
          const remainingText = s.text.substring(localOffset);
          
          if (remainingText) {
            isPausingManually = false;
            speak(remainingText, currentCharIndex);
          }
          return;
        }

        // Si en lecture, mettre en pause
        if (currentState === 'playing') {
          isPausingManually = true;
          try {
            window.speechSynthesis.cancel();
            // Attendre un peu avant de mettre à jour l'UI
            setTimeout(() => {
              updateUI('paused');
              isPausingManually = false;
            }, 100);
          } catch (e) {
            console.error('Error pausing speech:', e);
            isPausingManually = false;
          }
          return;
        }

        // Sinon démarrer du début
        if (!contentText) {
          prepareText();
        }
        
        let bodyText = "";
        if (articleContent) {
          bodyText = contentText || (articleContent as HTMLElement).innerText;
        }

        // No need to filter bodyText anymore as ignored content is excluded from wordMap/contentText
        fullText = titleText + bodyText;
        if (fullText.trim().length <= titleText.length) {
           console.warn("No text content found to speak.");
           return;
        }
        
        // Split into sentences for better reliability
        const rawSentences = fullText.match(/[^.!?]+[.!?]+(\s+|$)|[^.!?]+$/g) || [fullText];
        let cursor = 0;
        sentences = rawSentences.map(t => {
            const entry = { text: t, start: cursor };
            cursor += t.length;
            return entry;
        });

        currentCharIndex = 0;
        currentSentenceIndex = 0;
        isPausingManually = false;
        
        if (sentences.length > 0) {
            speak(sentences[0].text, sentences[0].start);
        }
      });

      stopButton.addEventListener('click', () => {
        try {
          isPausingManually = false;
          window.speechSynthesis.cancel();
          clearHighlight();
          currentCharIndex = 0;
          updateUI('stopped');
        } catch (e) {
          console.error('Error stopping speech:', e);
        }
      });
    });

    if (window.speechSynthesis) {
        window.speechSynthesis.onvoiceschanged = () => {
          window.speechSynthesis.getVoices();
        };
    }
  }

  if (document.readyState !== 'loading') {
    initTTS();
  } else {
    document.addEventListener('DOMContentLoaded', initTTS);
  }
  
  document.addEventListener('astro:page-load', initTTS);
</script>
